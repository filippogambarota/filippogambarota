{
  "hash": "762fdefcd95d4b81528a5e98952392c0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Machine Learning Notes\"\ndate: \"2024-01-28\"\ncategories: [linear-regression]\n---\n\n\n\n\n# Packages\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(caret)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: ggplot2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: lattice\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(glmnet)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: Matrix\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoaded glmnet 4.1-8\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(purrr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'purrr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:caret':\n\n    lift\n```\n\n\n:::\n:::\n\n\n# Functions\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_rmse <- function(errors){\n  sqrt(mean(errors^2))\n}\n```\n:::\n\n\n# LOO-CV\n\n## Custom LOO-CV function\n\nThis function implement a *not elegant* function for testing the **loo-cv**. Is useful for understanding the idea:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_loocv <- function(fit){\n  \n  dat <- fit$model\n  y <- all.vars(fit$call)[1]\n  \n  errors <- vector(mode = \"numeric\", length = nrow(dat))\n  \n  for(i in 1:nrow(dat)){\n    to_pred_i <- dat[i, ]\n    fit_no_i <- update(fit, data = dat[-i, ])\n    pred_i <- predict(fit_no_i, to_pred_i)\n    errors[i] <- pred_i - to_pred_i[1, y]\n  }\n  return(errors)\n}\n```\n:::\n\n\nComparing with the function from **caret**, this is the **OLS** model:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncaret_ols <- train(mpg ~ disp + wt, \n               data = mtcars, \n               trControl=trainControl(method=\"LOOCV\"), \n               method=\"lm\")\n```\n:::\n\n\nMy custom function:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstandard_ols <- lm(mpg ~ disp + wt, data = mtcars)\nmy_loocv <- get_rmse(my_loocv(standard_ols))\n```\n:::\n\n\nThe output is exactly the same:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncaret_ols$results[\"RMSE\"] == my_loocv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  RMSE\n1 TRUE\n```\n\n\n:::\n:::\n\n\n## LOO-CV and model complexity\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npredictors <- colnames(mtcars) # getting all predictors\npredictors <- predictors[-(predictors == \"mpg\")] # keeping only Xs\n\nfit_list <- vector(mode = \"list\", length = length(predictors))\n\nfit_i <- lm(mpg ~ 1, data = mtcars)\n\nfor(i in 1:length(predictors)){\n  fit_i <- update(fit_i, formula(paste(\". ~ . +\", predictors[i])))\n  fit_list[[i]] <- fit_i\n}\n```\n:::\n\n\nComputing the actual LOO-CV:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_loocv <- function(fit){\n  \n  dat <- fit$model\n  y <- all.vars(fit$call)[1]\n  \n  errors <- vector(mode = \"numeric\", length = nrow(dat))\n  \n  for(i in 1:nrow(dat)){\n    to_pred_i <- dat[i, ]\n    fit_no_i <- update(fit, data = dat[-i, ])\n    pred_i <- predict(fit_no_i, to_pred_i)\n    errors[i] <- pred_i - to_pred_i[1, y]\n  }\n  return(errors)\n}\n\ncv <- map_dbl(fit_list, function(x) get_rmse(my_loocv(x))) # get loo-cv mean error\nnpred <- map_dbl(fit_list, function(i) length(all.vars(i$call))-2) # get number of predictors\nr2 <- map_dbl(fit_list, function(mod) summary(mod)$r.squared) # get rsquared from fitted models\n\nloo_cv <- data.frame(\n  cv, r2, npred\n)\n\n# Plotting\n\nloo_cv %>% \n  tidyr::pivot_longer(c(1,2), names_to = \"measure\", values_to = \"value\") %>% \n  ggplot(aes(x = npred, y = value)) +\n  geom_line() +\n  geom_point(size = 3) +\n  facet_wrap(~measure, scales = \"free\") +\n  cowplot::theme_minimal_grid()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n## LOO-CV and Lasso regression\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngrid <- 10^seq(1, -2, length = 100) # grid of lambda values\nx <- model.matrix(mpg ~ ., mtcars)[, -1] # predictors\ny <- mtcars$mpg # response variable\n```\n:::\n\n\nFitting the **lasso** regression:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfit_lasso <- glmnet(x, y, alpha = 1, lambda = grid)\n```\n:::\n\n\nCustom function for computing the **lasso** and **loo-cv**:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_loocv_lasso <- function(dat, fit){\n  \n  errors <- vector(mode = \"list\", length = nrow(dat))\n  \n  for(i in 1:nrow(dat)){\n    to_pred_i <- x[i, ]\n    fit_no_i <- glmnet(x[-i, ], y[-i], alpha = 1, lambda = grid)\n    pred_i <- predict(fit_no_i, newx = t(to_pred_i))\n    errors[[i]] <- pred_i - y[i]\n  }\n  return(errors)\n} \n\nget_min <- function(target, to_minimize){\n  target[which.min(to_minimize)]\n}\n```\n:::\n\n\nComputing the loo-cv:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nerrors_lasso <- my_loocv_lasso(mtcars, fit_lasso) # loo-cv\n\ncv_lasso <- do.call(rbind, errors_lasso) # combining lists\n\nmse_lasso <- apply(cv_lasso, 2, function(x) mean(x^2)) # computing error\n```\n:::\n\n\nPlotting the $\\lambda$ value as a function of the mean-squared error:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(grid, mse_lasso)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nThe minimum error is associated with the 0.7564633.\n\n\n\n\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}